# [Problem Number]. [Problem Title]

<!-- ***METADATA*** - used for search/filtering -->

<!--
difficulty: Easy | Medium | Hard
topics: [array, hash-map, sliding-window, two-pointers, binary-search, dynamic-programming, recursion, backtracking, greedy, graph, bfs, dfs, tree, linked-list, stack, queue, heap, trie, math, string, bit-manipulation]
companies: [google, amazon, meta, apple, microsoft, bloomberg, uber, airbnb]
date_solved: YYYY-MM-DD
status: solved | revisit | unsolved
time_complexity: O()
space_complexity: O()
-->

**Difficulty:** `Easy` / `Medium` / `Hard`  
**Topics:** `topic1` `topic2` `topic3`  
**Companies:** `company1` `company2`  
**Date Solved:** YYYY-MM-DD  
**Status:** âœ… Solved / ðŸ” Revisit / âŒ Unsolved  

ðŸ”— [LeetCode Link](https://leetcode.com/problems/problem-name/)

---

## Problem

> Paste or summarize the problem statement here.

**Example:**
```
Input: 
Output: 
Explanation: 
```

**Constraints:**
- 

---

## Intuition

<!-- What was your first instinct? What pattern did you recognize? -->

---

## Approach

<!-- Walk through your approach step by step before jumping to code. -->

1. 
2. 
3. 

**Time Complexity:** `O()`  
**Space Complexity:** `O()`

---

## Solution

```cpp
// C++ solution


```

---

## Alternative Approaches

### Approach 2: [Name]
<!-- Briefly describe trade-offs vs your main approach -->

```cpp


```

**Time:** `O()` | **Space:** `O()`

---

## Edge Cases

- [ ] Empty input
- [ ] Single element
- [ ] All duplicates
- [ ] Negative numbers
- [ ] Max constraints

---

## Notes & Mistakes

<!-- What tripped you up? What would you do differently next time? -->


<!-- 
